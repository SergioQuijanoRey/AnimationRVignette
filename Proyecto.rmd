---
title: "Animaciones en R con el paquete animation"
author: "Lucía Salamanca López, Sergio Quijano Rey, Alejandro Borrego Megías"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Animaciones en R


Durante el curso hemos explorado las posibilidades de R en el ámbito de la Estadística computacional, haciendo análisis exploratorio de datos, problemas de regresión lineal, aproximación de integrales y distribuciones, etc... Además hemos explorado diversas funciones que permiten generar gráficos que ayudan a explicar y entender mejor estos procedimientos. 

Motivados por la gran potencia de R para la generación de gráficos decidimos explorar si también existen paquetes que permitan crear animaciones para comprender mejor algoritmos clásicos tanto de estadística como de la matemática aplicada en general. Es por ello que nuestro proyecto se basa en utilizar algunas de las funciones del paquete *animation* y valorar los resultados que se obtienen.

El paquete *animation* proporciona un extenso catálogo de funciones que abarcan problemas de la teoría de probabilidad, la estadística multivariante, modelos lineales, series temporales y algoritmos de minería de datos y aprendizaje automático. La finalidad del paquete mostrar el funcionamiento de estas herramientas visualmente con una finalidad didáctica.

Es importante mencionar que las animaciones no se pueden visualizar en este HTML, cada una de las funciones que usemos genera un HTML con un nombre de acuerdo a la función que permitirá ver la animación y controlar su ejecución permitiendo aumentar o disminuir la velocidad, o parar la animación en un instante determinado. Estos ficheros se entregan junto con el proyecto final.

## Instalación del paquete *animation*

Para la instalación del paquete lo hacemos a través de **CRAN** como con el resto de paquetes que hemos empleado durante el curso.  
```{r}
#install.packages("animation")

```
```{r}
library(animation)
```


## Ejemplos 

A continuación se muestran algunos ejemplos de uso de algunas de sus funciones, como se verá, en todos los casos hacemos uso de una función denominada `saveHTML()`, que nos permite convertir en un fichero HTML cada una de las animaciones, como parámetros debemos pasar la secuencia de imágenes que compoenen la animación y que son generadas por la función principal, y el nombre del fichero HTML que queremos generar. 

### Método de Bisección

La siguiente función aplica el método de Bisección para encontrar una raíz de cierta función continua $f(x)$. Si recordamos el método, este requiere de dos puntos iniciales $a,b$ de manera que $f(a)>0$ y $f(b)<0$ o viceversa. De esta forma, por el teorema de Bolzano sabemos que en el intervalo $[a,b]$ hay una raíz de la función.

El algoritmo en cada iteración calcula el punto medio $c$ del intervalo $[a,b]$ y evalúa la función en ese punto medio, si el signo es igual que $f(a)$ reemplaza $a$ por $c$ y si no al contrario. De esta manera vamos reduciendo el intervalo en que se encuentra la raíz hasta que se obtenga la raíz exacta o bien se sobrepase una cierta tolerancia.

En nuestro caso vamos a probar con la función $f(x)=x^3 - 7x -10$ y vamos a usar el intervalo $[-3,5]$ pues como vemos en ese intervalo se cumplen las condiciones del algoritmo y hay una raíz.


```{r}
f = function(x) x^3 - 7 * x - 10
curve(f, from = -3, to=5)
abline(h=0)
```

A continuación usamos la función de animation correspondiente, se trata de `bisection.method` y requiere como parámetros la función $f$ que usaremos y los valores iniciales $a,b$ del método de bisección:
```{r, dev='png'}
saveHTML({bisection.method(f, c(-3, 5))
},htmlfile = "Biseccion.html")
```


### Método de Gradiente Descendente 

Vamos a explorar la función que permite visualizar el método para encontrar mínimos locales de funciones en dos dimensiones (en este caso) conocido como Gradiente Descendente. 

El método sigue la intuición de que el gradiente de una función apunta siempre a máximos locales, luego lo que hacemos es ir en la dirección contraria del gradiente para tratar de hallar mínimos locales. Este método no garantiza que el mínimo obtenido sea el mínimo global de la función (a no ser que la función sea convexa).

Para ello partimos de un punto inicial aleatorio del dominio de la función, y en cada iteración nos desplazamos en la dirección que apunta el gradiente cambiado de signo dando un paso de cierto tamaño que idealmente será grande para aproximarse rápido al mínimo y luego se reducirá para ajustar con precisión dicho mínimo.

La función que emplearemos será: 

```{r, dev='png'}
f1 = function(x, y) x^2 + 3 * sin(y)
x <- seq(pi*-2,pi*2,length.out=100)
y <- seq(pi*-2,pi*2,length.out=100)
z <- outer(x^2,3* sin(y),`+`)
persp(x,y,z,theta = 30)
```
Como podemos apreciar en la imagen, la función tiene dos mínimos en el domino que usaremos que es $[-2\pi,2\pi] \times [-2\pi,2\pi]$.

Para esta tarea usaremos la función `grad.desc`. Los parámetros que debemos pasarle son: La función que vamos a usar, el dominio en el que trabajaremos y el punto inicial, que en nuestro caso será el $(-2\pi,2)$.

```{r, dev='png'}
saveHTML({grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD.html")
```


### Integración de Monte Carlo

El paquete animation incluye una función que realiza la animación del método de integración de Monte Carlo.

Este método utiliza números aleatorios para calcular el valor de integrales del estilo:

$$ I = \int \limits_0^1 h(x) dx$$
Para ello, teniendo en cuenta que la función de densidad de la distribución uniforme en el intervalo $(0,1)$ es $f(x)=1$, podemos escribir la integral anterior como:

$$ I = \int \limits_0^1 h(x) dx = \Bbb{E}[h(X)]$$

Donde $X \sim \mathcal{U}$. Al describirlo como una media teórica, podemos aproximarla simulando $n$ variables aleatorias uniformes $X_1,\dots,X_n$: 

$$ I = \int \limits_0^1 h(x) dx = \Bbb{E}[h(X)] \approx \frac{1}{n}  \sum_{i=1}^{n}h(X_i)$$

Lo que muestra la función `MC.samplemean` son los rectángulos de ancho $\frac1n$ y de alto $h(x_i)$. De esta manera podemos comparar gráficamente la diferencia entre el valor exacto de la integral y la aproximación por el método de Monte Carlo.


Los argumentos de la función son: la función a integrar, el número de puntos que se toman de la distribución uniforme, el color de los rectángulos y si las posiciones de los rectángulos en el eje x deben ser ajustadas. 

Esta función devuelve una lista con los números aleatorios generados, la función evaluada en dicho puntos, el valor de la n y el valor estimado de la integral. 

Vamos a mostrar un ejemplo con la función $h(x) =4x^4$.

Primero mostramos un gráfico de la función:

```{r, fig.align='center',fig.cap='Función a integrar'}
# definimos la función a integrar
h<-function(x) (4*x^4) * (x>0 & x<1)
# visualizamos la función en el dominio de integración16
curve(h,0,1)
```
```{r,dev='png', include = FALSE}
set.seed(1)
montecarlo<-MC.samplemean(FUN = h,adj.x = FALSE, col.rect = c(rgb(0, 0, 0, 0.3), rgb(1, 0, 0)), border = NA, n=60)
saveHTML({montecarlo},htmlfile = "MonteCarlo.html")
```

```{r}
# Mostramos la estimación de la integral
montecarlo$est
```

Sabemos que el valor de la integral es $\frac{4}{5}$ por lo que el error relativo de la aproximación es de:

```{r}
abs(montecarlo$est-4/5)/(4/5)
```

Podemos encontrar la animación en el archivo _MonteCarlo.html_.
