---
title: "Animaciones en R con el paquete animation"
author:
    - "Lucía Salamanca López"
    - "Sergio Quijano Rey"
    - "Alejandro Borrego Megías"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Animaciones en R con el apquete animation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- Este codigo es necesario para inicializar el documento tipo Vignette -->
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introducción

En este *vignette* vamos a mostrar varios ejemplos de uso del paquete `animation`. Este paquete contiene una serie de funciones para realizar animaciones sobre distintas aplicaciones de la estadística ^[Como muestra la [documentación oficial del paquete](https://cran.r-project.org/web/packages/animation/animation.pdf)]. El paquete también ofrece funciones para guardar las animaciones en distintos formatos, como `PDF`, `GIF`, `HTML`, ...

Además de este *vignette*, se puede consultar la [documentación oficial del paquete](https://cran.r-project.org/web/packages/animation/animation.pdf).

Notar que no vamos a poder mostrar ejemplos de todas las funciones del paquete por la gran extensión en funcionalidad de este mismo.

# Instalación y carga del paquete

Para instalar el paquete, podemos usar el siguiente código:

```{r eval = FALSE}
install.packages("animation")
```

Una vez ejecutada esta orden para instalar el paquete, lo podemos cargar:

```{r}
library(animation)
```

# Ejemplos

## Clasificación usando *k-NN*

*k-NN* o *k-Vecinos más cercanos* es un algoritmo de clasificación supervisado, no paramétrico. El procedimiento de este algoritmo es muy sencillo:

1. Guardamos una serie de datos que servirán para clasificar futuras entradas
   - Notar que no hay proceso de aprendizaje, solamente almacenamos los ejemplos de entrenamiento
2. Cuando llega un ejemplo a clasificar:
    - Miramos la clase de las $k$ clases más cercanas al ejemplo
    - Elegimos la clase del nuevo ejemplo, normalmente por voto mayoritario (para ello, lo ideal es que $k$ sea un número impar)
    - Con el valor de $k$ controlamos la regularización que queremos introducir en el modelo. Un valor más alto de $k$ implica una regularización mayor

Para mostrar esto con un ejemplo, trabajamos con un dataset que queremos segmentar en distintos clusters. En concreto, trabajaremos con el conocido *Iris Dataset*. Nuestro objetivo es clasificar los datos en tres tipos de flores: *setosa*, *versicolor* y *virginica*. Para ello, escogeremos dos características de las cuatro disponibles:

1. Sepal.Length
2. Sepal.Width
3. Petal.Length
4. Petal.Width

Nos quedamos con las dos primeras variables.

```{r}
# El dataset iris esta pre-cargado en R
data <- iris
head(data)

# Nos quedamos solo con dos columnas, porque la animacion solo soporta dos
# dimensiones
data <- data[, c("Sepal.Length", "Sepal.Width")]
head(data)
```

Con esto, ya podemos aplicar el algoritmo que visualizaremos:

```{r}
# Nos fijaremos en los cinco vecinos más cercanos
k <- 5


# Establecemos la velocidad de la animacion
ani.options(interval = 1)

# Coloco la ejecucion del algoritmo en una funcion para tener un codigo limpio
# (no poner esto en `saveHTML`) y para que no se muestre en el documento html
# principal, sin animar
generate_result <- function() {
    return(knn.ani(
        data,
        k <- k,
    ))
}

# Aplicamos el algoritmo, salvandolo en un fichero html para visualizarse
saveHTML(
    generate_result(),
    htmlfile = "kNN.html"
)
```

El resultado lo podemos visualizar en [este documento html](kN.html)

## Clusterización usando K-means

> TODO -- describir el algoritmo

Volvemos a trabajar con el mismo *dataset*, quedándonos con las mismas variables:

```{r}
# El dataset iris esta pre-cargado en R
data <- iris
head(data)

# Nos quedamos solo con dos columnas, porque la animacion solo soporta dos
# dimensiones
data <- data[, c("Sepal.Length", "Sepal.Width")]
head(data)
```

Aunque el algoritmo sea una algoritmo de aprendizaje no supervisado, sabemos que tenemos 3 tipos de flores, así que establecemos a 3 el número de centros:

```{r}
num_centers <- 3
```

Con esto, ya podemos aplicar el algoritmo que visualizaremos:

```{r}

# Establecemos la velocidad de la animacion
ani.options(interval = 1)

# Coloco la ejecucion del algoritmo en una funcion para tener un codigo limpio
# (no poner esto en `saveHTML`) y para que no se muestre en el documento html
# principal, sin animar
generate_result <- function() {
    return(kmeans.ani(
        x = data,
        centers <- num_centers,
    ))
}

# Aplicamos el algoritmo, salvandolo en un fichero html para visualizarse
saveHTML(
    generate_result(),
    htmlfile = "kMeans.html"
)
```

El resultado lo podemos visualizar en [este documento html](kMeans.hmtl)

